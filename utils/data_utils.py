import json
import logging
import pandas as pd 
import re 
import requests
from tqdm import tqdm
from lingua import Language, LanguageDetectorBuilder
import phunspell
from rdflib import Graph
from rdflib.namespace import SKOS  
from collections import Counter 

CHANGED_LABELS = {}

def ensure_first_letter_capitalized(text: str) -> str:
    """  
    Ensures that the first letter of a given string is capitalized.  
  
    This function checks if the input string is empty and returns it unchanged if so. Otherwise, it capitalizes the first letter while leaving the rest of the string unchanged.  
  
    Parameters:  
    -----------  
    text : str  
        The input string to be processed.  
  
    Returns:  
    --------  
    str  
        The input string with the first letter capitalized, if applicable.  
    """    
    if not text:  
        return text  # Return the original text if it's empty  
    return text[0].upper() + text[1:]  

def cleaning_label(label: str, uri: str, rules: list) -> str:
    """  
    Cleans a label by replacing specific special characters with spaces and capitalizing the first letter.  
  
    This function uses a regular expression to replace a set of special characters in the input label with spaces. It then ensures the first letter of the resulting string is capitalized.  
  
    Parameters:  
    -----------  
    label : str  
        The input label string to be cleaned.
    uri : str  
        The uri of input label string to be cleaned. 
    rules: list
        Series of changes to make to the labels of the taxonomy elements.

    Returns:  
    --------  
    str  
        The cleaned label with special characters replaced and the first letter capitalized.  
    """ 
    for rule in rules:    
        for rule_label in rule:
            # Escape each character for regex use  
            _from = rule[rule_label]["from"]
            escaped_chars = [re.escape(char) for char in _from]  
            
            # Join them into a string with no separator  
            char_class = ''.join(escaped_chars)  
            
            # Build the regex pattern with negation  
            pattern = f'[{char_class}]'
            regex = re.compile(pattern)

            _to = rule[rule_label]["to"]
            _exceptions = rule[rule_label]["exceptions"]
            if regex.findall(label):
                if(label in _exceptions):
                    logging.info(f"Label excluded: \"{label}\"")
                else:
                    CHANGED_LABELS[rule_label].append(label)
                    # Replace them with a space  
                    label = re.sub(pattern, _to, label)

    return ensure_first_letter_capitalized(label)

pspell_fr = phunspell.Phunspell('fr_FR')
pspell_en = phunspell.Phunspell('en_GB')

def check_mispell(definition: str) -> None:
    """    
    Checks a definition for any misspelled words using French and English dictionaries.    
    
    This function uses a regular expression to split the definition into words, filtering out punctuation and whitespace. It checks for spelling errors first against a French dictionary, then against an English dictionary.    
    
    Parameters:    
    -----------    
    definition : str    
        The text definition to be checked for spelling errors.    
    
    Returns:    
    --------    
    None    
    
    Side Effects:    
    -------------    
    - Logs any misspelled words found in the definition to the console.    
    """ 
    b = ["," , ";" , "." , '"' , "(" , ")." , ")" , ":" , "?)," , ".)" , ")," , "/" , ");" , ".)." , "\"." , ".)," , "?." , "?" , "\"," , "%" , "#" , "!" , "&" , ".;", ",…." , "…." , "»" , "«" , "…)," , "…)" , "...)." , "@" , ".:" , "…)." , "…" , "'" , "€," , "”," , "'”" , ")-", '?".' , '?",' , '?"']  
    escaped_separators = list(map(re.escape, b))  
    
    # Construct the regex pattern  
    # The pattern will match any of the separators or whitespace  
    pattern = r'(' + '|'.join(escaped_separators) + r'|\s+)'

    res = list(filter(None, re.split(pattern, definition)))
    result = list(set(res) - set(b))
    mispelled_fr = pspell_fr.lookup_list(result)
    mispelled_en = pspell_en.lookup_list(mispelled_fr)
    if(len(mispelled_en) > 0):
        logging.info(f" mispelled: {mispelled_en} in {definition}")


def get_uri(namespace: str, concept:dict, level: int) -> str:
    """  
    Constructs a URI for a concept within a specified namespace and level.  
  
    This function creates a URI by concatenating a namespace with a slug derived from the concept's name. The slug is generated by converting the concept's name to lowercase and replacing spaces with underscores.  
  
    Parameters:  
    -----------  
    namespace : str  
        The base namespace for constructing the URI.  
    concept : dict  
        A dictionary containing the concept's details, including its name.  
    level : int  
        The level of the concept in the taxonomy, used to access the appropriate field in the concept dictionary.  
  
    Returns:  
    --------  
    str  
        The constructed URI for the concept.  
    """  
    slug = concept[f"Slug Catégorie L{level}"].lower().replace(" ", "_")
    uri = namespace + slug

    return uri

def find_duplicate_values(taxo_graph: Graph) -> str:
    """  
    Finds duplicate values in the taxonomy labels and logs them.  
    
    Parameters:  
    -----------  
    taxo_graph : Graph    
        The RDFLib Graph object to which RDF triples are added.  
  
    Returns:  
    --------  
    duplicates: str
        List of duplicate prefLabel  
    """  
    # Extract all skos:prefLabel values  
    pref_labels = []  
    
    for s, p, o in taxo_graph:  
        if p == SKOS.prefLabel and o.language == 'fr':  
            pref_labels.append(str(o))  
    
    # Find duplicate prefLabels  
    label_counts = Counter(pref_labels)  
    duplicates = [label for label, count in label_counts.items() if count > 1]   
    
    return "; ".join(duplicates)     

def taxonomy_size_validation(taxo_graph: Graph, taxo_size: int) -> int:
    
    query = """
    SELECT (count(?conceptOrScheme) as ?total)
    WHERE {
        ?conceptOrScheme rdf:type ?type
    }
    """

    count = taxo_graph.query(query)
    
    for row in count: 
        if int(row.total) != int(taxo_size):
            logging.info(f"Validation failed: {int(taxo_size) - int(row.total)} concepts were dropped during the process")
        else: 
            logging.info(f"Validation passed: The number of concepts in the taxonomy is {row.total}")

def shacl_validation(turtle_data: str, validation_server: str, output_format: str, validation_version: str) -> None:
    """  
    Validates RDF data in Turtle format using a SHACL API.  
  
    This function sends a POST request to a SHACL validation API with the RDF data. It checks the API response to determine if the RDF conforms to the SHACL shapes and prints validation results.  
  
    Parameters:  
    -----------  
    turtle_data : str  
        The RDF data in Turtle format to be validated. 
    validation_server : str  
        The API endpoint used for validating the resulting RDF file. 
    output_format : str  
        The format of the resulting rdf to be validated.
  
    Returns:  
    --------  
    None  
  
    Side Effects:  
    -------------  
    - Sends an HTTP POST request to a SHACL API.  
    - Prints validation results to the console, indicating success or failure and any errors detected.  
  
    Raises:  
    -------  
    Exception  
        If the HTTP request fails or the API returns an error response.  
    """  
    # Prepare the API request payload  
    payload = {  
        "contentToValidate": turtle_data,  
        "contentSyntax": f"{output_format}",  
        "validationType": f"{validation_version}"  
    }  


    # Send the POST request 
    response = requests.post(validation_server, json=payload)  

    # Check the response  
    if response.status_code == 200:  
        if response.json().get("sh:conforms"):
            logging.info("Validation successful: No errors in the taxonomy")
        else: 
            logging.info("Validation failed: Errors detected:\n" + response.text) 
    else:  
        logging.info("Error with the API call to ITB validator:" + response.status_code + response.text)
